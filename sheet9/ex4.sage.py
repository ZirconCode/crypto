
# This file was *autogenerated* from the file ex4.sage
from sage.all_cmdline import *   # import sage library

_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_88 = Integer(88); _sage_const_45 = Integer(45); _sage_const_5 = Integer(5); _sage_const_47 = Integer(47); _sage_const_112 = Integer(112); _sage_const_9 = Integer(9); _sage_const_4 = Integer(4); _sage_const_42 = Integer(42); _sage_const_17 = Integer(17); _sage_const_20 = Integer(20); _sage_const_18 = Integer(18); _sage_const_19 = Integer(19); _sage_const_6 = Integer(6)
E = EllipticCurve(GF(_sage_const_47 ),[_sage_const_1 ,_sage_const_2 ])
P = E(_sage_const_18 ,_sage_const_20 )
Q = E(_sage_const_1 ,_sage_const_45 )

ord = P.order()
print 'p ord ', ord

# 'randomness' inspired by Elliptic Curves etc. - Lawrence C. Washington
P0 = _sage_const_3 *P + _sage_const_5 *Q


M = [(_sage_const_4 ,_sage_const_3 ), (_sage_const_9 ,_sage_const_17 ), (_sage_const_19 ,_sage_const_6 )]

def f(point):
	i = mod(point[_sage_const_0 ],_sage_const_3 )
	return (point+M[i][_sage_const_0 ]*P+M[i][_sage_const_1 ]*Q , M[i])

#print f(P0)

def Pi(i):
	res = P0
	coeff = (_sage_const_3 ,_sage_const_5 ) # for P0

	for j in range(i):
		tmp = f(res)
		res = tmp[_sage_const_0 ]
		coeff = [sum(x) for x in zip(coeff,tmp[_sage_const_1 ])]
	return (res,coeff)

print P0
print Pi(_sage_const_0 )
print Pi(_sage_const_1 )
print Pi(_sage_const_2 )


for k in range(_sage_const_1 ,ord):
	p1 = Pi(k)
	p2 = Pi(_sage_const_2 *k)
	if p1[_sage_const_0 ] == p2[_sage_const_0 ]:
		print k , 'wooo collision'
		print p1
		print p2
		#break

# first collision at 9

# we use second collision at 18 since first one doesn't work out
print _sage_const_112 *P + _sage_const_88 *Q # gives point in infinity = good

print _sage_const_42 *P
print Q

